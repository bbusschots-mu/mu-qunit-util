<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/muQUnitUtil.js | @maynoothuniversity/mu-qunit-util</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Qunit utilities for use in Maynooth University projects."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@maynoothuniversity/mu-qunit-util"><meta property="twitter:description" content="Qunit utilities for use in Maynooth University projects."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/bbusschots-mu/mu-qunit-util"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/muQUnitUtil.js~DummyData.html">DummyData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyBasicData">dummyBasicData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyBasicDataExcept">dummyBasicDataExcept</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyBasicPrimitives">dummyBasicPrimitives</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyBasicPrimitivesExcept">dummyBasicPrimitivesExcept</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyData">dummyData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyDataByType">dummyDataByType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyDataExcept">dummyDataExcept</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyDataWithAllTags">dummyDataWithAllTags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dummyDataWithAnyTag">dummyDataWithAnyTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-refreshDummyData">refreshDummyData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-muQUnitUtil">muQUnitUtil</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/muQUnitUtil.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const is = require(&apos;is_js&apos;);

/**
 * The exported namespace.
 *
 * All public functions are exported via this namespace.
 *
 * @type {Object}
 * @property {Map&lt;string, Map&lt;string, DummyData&gt;&gt;} allDummyData - The library
 * of dummy data organised by type and period-separated tag path.
 * 
 * This data structure is generated by the {@link refreshDummyData} function.
 */
const muQUnitUtil = {
    /**
     * The library of dummy data organised by type and period-separated tag
     * path.
     *
     * This data structure is generated by the `refreshDummyData()` function.
     *
     * @type {Map&lt;string, Map&lt;string, DummyData&gt;&gt;}
     * @see {@link refreshDummyData}
     */
    allDummyData: {}
};
module.exports = muQUnitUtil;

/**
 * A dummy data definition encapsulating the piece of data itself, a
 * description, and one or more tags.
 *
 * @private
 */
class DummyData{
    
    /**
     * @param {string} desc - a description of the piece of data.
     * @param {string[]} tags - zero or more tags to associate with the data.
     * @param {*} val - the actual piece of data.
     * @param {string} [type] - the data&apos;s type.
     * @param {string} [tagPath] - the data&apos;s tag path.
     */
    constructor(desc, tags, val, type, tagPath){
        if(!(is.string(desc) &amp;&amp; is.not.empty(desc))) throw new TypeError(&apos;description must be a non-empty string&apos;);
        if(!(is.array(tags) &amp;&amp; is.all.string(tags))) throw new TypeError(&apos;tags must be an array of strings&apos;);
        if(is.not.undefined(type) &amp;&amp; is.not.string(type)) throw new TypeError(&apos;if p, type must be a string&apos;);
        this._description = desc;
        this._tags = [...tags];
        this._value = val;
        this._tagLookup = {};
        this._type = type;
        this._tagPath = tagPath;
        for(const t of this._tags){
            this._tagLookup[t] = true;
        }
    }
    
    /*
     * @type {string}
     */
    get description(){
        return this._description;
    }
    
    /**
     * @type {string[]}
     */
    get tags(){
        return this._tags;
    }
    
    /**
     * @type {*}
     */
    get value(){
        return this._value;
    }
    
    /**
     * @type {string|undefined}
     */
    get type(){
        return this._type;
    }
    
    /**
     * @type {string|undefined}
     */
    get tagPath(){
        return this._tagPath;
    }
    
    /**
     * @return {boolean}
     */
    hasTag(t){
        if(is.not.string(t)) throw new TypeError(&apos;tag must be a string&apos;);
        return this._tagLookup[t] ? true : false;
    }
}

/**
 * Refresh the dummy data.
 *
 * @alias refreshDummyData
 * @param {...function(): Map&lt;string, Map&lt;string, Array&gt;&gt;} dataGenerators -
 * references to zero or more functions that return additional dummy data
 * beyond the default set. The generators must return a data structure
 * containing three-element arrays indexed by tag path indexed by type. The
 * first element in the arrays must be a textual description of the piece
 * of dummy data, the second a list of additional tags as an array of
 * strings (the tags that make up the tag path should not be included), and
 * the dummy data value. E.g.:
 *
 * ```
 * function muDummyDataGen(){
 *     return {
 *         number: {
 *             &apos;mu.studentNumber&apos;: [&apos;a student number&apos;, [&apos;integer&apos;], 99999999]
 *         },
 *         string: {
 *             &apos;mu.studentNumber&apos;: [&apos;a student number string&apos;, [&apos;integer&apos;, &apos;numeric&apos;], &apos;99999999&apos;]
 *         }
 *     };
 * }
 * ```
 */
function refreshDummyData(...dataGenerators){
    // The data structure defining the default dummy data - see the relevant
    // page in the manual section of the docs for details.
    const rawData = {
        &apos;boolean&apos;: {
            &apos;true&apos;: [&apos;true&apos;, [&apos;basic&apos;], true],
            &apos;false&apos;: [&apos;false&apos;, [&apos;falsy&apos;], false]
        },
        &apos;number&apos;: {
            &apos;zero&apos;: [&apos;the number zero&apos;, [&apos;integer&apos;, &apos;falsy&apos;], 0],
            &apos;digit&apos;: [&apos;a single-digit number&apos;, [&apos;integer&apos;], 7],
            &apos;integer&apos;: [&apos;a positive integer&apos;, [&apos;basic&apos;], 12345],
            &apos;integer.2digit&apos;: [&apos;a 2-digit number&apos;, [], 42],
            &apos;integer.3digit&apos;: [&apos;a 3-digit number&apos;, [], 123],
            &apos;integer.4digit&apos;: [&apos;a 4-digit number&apos;, [], 1982],
            &apos;uts&apos;: [&apos;a numeric Unix Time-stamp&apos;, [&apos;datetime&apos;, &apos;integer&apos;], 1529660265],
            &apos;integer.negative&apos;: [&apos;a negative integer&apos;, [], -12345],
            &apos;float&apos;: [&apos;a positive floating point number&apos;, [], 3.14],
            &apos;float.negative&apos;: [&apos;a negative floating point number&apos;, [], -3.14]
        },
        &apos;string&apos;: {
            &apos;empty&apos;: [&apos;an empty string&apos;, [&apos;falsy&apos;], &apos;&apos;],
            &apos;word&apos;: [&apos;a single-word string&apos;, [&apos;basic&apos;], &apos;boogers&apos;],
            &apos;line&apos;: [&apos;a single-line string&apos;, [], &apos;boogers and snot&apos;],
            &apos;multiline&apos;: [&apos;a multi-line string&apos;, [&apos;&apos;], &apos;boogers\nsnot\nbogeys&apos;],
            &apos;zero&apos;: [&apos;the character 0&apos;, [&apos;integer&apos;, &apos;numeric&apos;], &apos;0&apos;],
            &apos;digit&apos;: [&apos;a single-digit string&apos;, [&apos;integer&apos;, &apos;numeric&apos;], &apos;7&apos;],
            &apos;integer&apos;: [&apos;a positive integer string&apos;, [&apos;numeric&apos;], &apos;12345&apos;],
            &apos;integer.2digit&apos;: [&apos;a 2-digit numeric string&apos;, [&apos;numeric&apos;], &apos;42&apos;],
            &apos;integer.3digit&apos;: [&apos;a 3-digit numeric string&apos;, [&apos;numeric&apos;], &apos;123&apos;],
            &apos;integer.4digit&apos;: [&apos;a 4-digit numeric string&apos;, [&apos;numeric&apos;], &apos;1982&apos;],
            &apos;uts&apos;: [&apos;a Unix Time-stamp string&apos;, [&apos;datetime&apos;, &apos;numeric&apos;, &apos;integer&apos;], &apos;1529660265&apos;],
            &apos;iso8601&apos;: [&apos;an ISO8601 date &amp; time string&apos;, [&apos;datetime&apos;], &apos;2018-06-22T09:37:45z&apos;],
            &apos;rfc2822&apos;: [&apos;an RFC2822 date &amp; time string&apos;, [&apos;datetime&apos;], &apos;Fri, 22 Jun 2018 09:37:45 +0000&apos;],
            &apos;jsdate&apos;: [&apos;a JavaScript date &amp; time string&apos;, [&apos;datetime&apos;], &apos;2018-06-22T09:37:45.000Z&apos;],
            &apos;integer.negative&apos;: [&apos;a negative integer string&apos;, [&apos;numeric&apos;], &apos;-12345&apos;],
            &apos;float&apos;: [&apos;a floating point numeric string&apos;, [&apos;numeric&apos;], &apos;3.14&apos;],
            &apos;float.negative&apos;: [&apos;a negative floating point numeric string&apos;, [&apos;numeric&apos;], &apos;-3.14&apos;]
        },
        &apos;array&apos;: {
            &apos;empty&apos;: [&apos;an empty array&apos;, [&apos;object&apos;], []],
            &apos;basic&apos;: [&apos;an array of primitives&apos;, [&apos;object&apos;, &apos;basic&apos;], [true, 42, &apos;boogers&apos;]]
        },
        &apos;function&apos;: {
            &apos;void&apos;: [&apos;a void function&apos;, [&apos;object&apos;, &apos;basic&apos;], function(){}]
        },
        &apos;error&apos;: {
            &apos;Error&apos;: [&apos;a generic error&apos;, [&apos;object&apos;, &apos;basic&apos;], new Error(&apos;a generic error&apos;)],
            &apos;TypeError&apos;: [&apos;a type error&apos;, [&apos;object&apos;], new TypeError(&apos;a type error&apos;)],
            &apos;RangeError&apos;: [&apos;a range error&apos;, [&apos;object&apos;], new TypeError(&apos;a range error&apos;)]
        },
        &apos;object&apos;: {
            &apos;null&apos;: [&apos;null&apos;, [&apos;empty&apos;, &apos;falsy&apos;, &apos;basic&apos;], null],
            &apos;empty&apos;: [&apos;empty object&apos;, [&apos;plain&apos;], {}],
            &apos;plain&apos;: [&apos;a plain object&apos;, [&apos;basic&apos;], {a: &apos;b&apos;, c: 42, d: true}],
            &apos;jsdate&apos;: [&apos;a date object&apos;, [&apos;datetime&apos;], new Date(&apos;2018-06-22T09:37:45.000Z&apos;)],
            &apos;jsdate.now&apos;: [&apos;a date object&apos;, [&apos;datetime&apos;], new Date()]
        },
        &apos;other&apos;: {
            &quot;undefined&quot;: [&apos;undefined&apos;, [&apos;empty&apos;, &apos;falsy&apos;, &apos;basic&apos;], undefined]
        }
    };
    const ans = {};
    
    // incorporate the default data
    for(const t of Object.keys(rawData)){
        ans[t] = {};
        for(const tp of Object.keys(rawData[t])){
            ans[t][tp] = new DummyData(
                rawData[t][tp][0],
                [...tp.split(&apos;.&apos;), ...rawData[t][tp][1]],
                rawData[t][tp][2],
                t,
                tp
            );
        }
    }
    
    // incporporate the data from the generator functions (if any)
    for(const genFn of dataGenerators){
        try{
            const extraData = genFn();
            if(is.not.object(extraData)) throw new TypeError(&apos;generator did not return an object&apos;);
            for(const t of Object.keys(extraData)){
                if(is.not.object(extraData[t])) throw new TypeError(`generatedData[&apos;${t}&apos;] is not an object`);
                if(is.undefined(ans[t])) ans[t] = {};
                for(const tp of Object.keys(extraData[t])){
                    if(is.not.array(extraData[t][tp])) throw new TypeError(`generatedData[&apos;${t}&apos;][&apos;${tp}&apos;] is not an array`);
                    if(is.not.string(extraData[t][tp][0])) throw new TypeError(`generatedData[&apos;${t}&apos;][&apos;${tp}&apos;][0] is not a string`);
                    if(is.not.array(extraData[t][tp][1]) || !is.all.string(extraData[t][tp][1])) throw new TypeError(`generatedData[&apos;${t}&apos;][&apos;${tp}&apos;][1] is not an array of strings`);
                    ans[t][tp] = new DummyData(
                        extraData[t][tp][0],
                        [...tp.split(&apos;.&apos;), ...extraData[t][tp][1]],
                        extraData[t][tp][2],
                        t,
                        tp
                    );
                }
            }
        }catch(err){
            throw new Error(`failed to load additional data from genereator function with error: ${err.message}`);
        }
    }
    
    // store the new data set
    muQUnitUtil.allDummyData = ans;
}
muQUnitUtil.refreshDummyData = refreshDummyData;

/**
 * Returns a single piece of dummy data, or, all the dummy data for a
 * given type, or all the dummy data.
 *
 * To get a single piece of dummy data pass its type and tag path as a
 * single period-separated string, e.g. `&apos;string.word&apos;` for the dummy data
 * with type `string` and tag path `word`, or `&apos;number.integer.negative&apos;`
 * for the dummy data with type `number` and tag path `integer.negative`.
 *
 * To get all the dummy data for a given type pass the type as a string,
 * e.g. `&apos;boolean&apos;` for all dummy boolean data.
 *
 * To get all the dummy data, simply pass `&apos;*&apos;`.
 *
 * When querying all the dummy data both entire sections and specific tags
 * can be excluded, and when querying all the dummy data for a sigle type
 * specific tags can be excluded.
 *
 * @param {string} path - a type, or, a type and tag path as a single
 * period-separated string, or the special value `&apos;*&apos;`.
 * @param {object} [opts] - an optional options object.
 * @param {string[]} [opts.excludeTypes] - a list of types to exclude when
 * requesting all dummy data (`path` is `&apos;*&apos;`).
 * @param {string[]} [opts.excludeTags] - a list of tags to exclude when
 * requesting all dummy data, or the dummy data for a given type.
 * @param {string[]} [opts.excludeDefinitions] - a list of individual data
 * definitions to exclude as period-separated type and tag path strings.
 * @return {DummyData[]|DummyData|undefined} Returns all the dummy data
 * for a given type, or a single piece of dummy data for a type with tag
 * path. If only a type is passed and that type does not exist an empty
 * array is returned, if the path has two or more parts and the type or
 * tag path don&apos;t exist, `undefined` is returned.
 * @throws {TypeError}
 */
function dummyData(path, opts){
    if(!(is.string(path) &amp;&amp; is.not.empty(path))) throw new TypeError(&apos;path must be a non-empty string&apos;);
    if(is.not.object(opts)) opts = {};
    const pathParts = path.split(&apos;.&apos;);
    const reqType = pathParts[0];
    
    // if a single piece of data or a single type is requested, and does not exist, return
    if(reqType !== &apos;*&apos;){
        if(is.not.object(muQUnitUtil.allDummyData[reqType])) return pathParts.length === 1 ? [] : undefined;
    }
    
    // deal with requests for a single piece of data
    if(pathParts.length &gt; 1) return muQUnitUtil.allDummyData[reqType][pathParts.slice(1).join(&apos;.&apos;)];
    
    // deal with requests for data for one or more types
    
    // figure out what types to process
    const typesToFetch = [];
    if(reqType === &apos;*&apos;){
        const typeSkipLookup = {};
        if(is.array(opts.excludeTypes)){
            for(const t of opts.excludeTypes) typeSkipLookup[t] = true;
        }
        for(const t of Object.keys(muQUnitUtil.allDummyData)){
            if(!typeSkipLookup[t]) typesToFetch.push(t);
        }
    }else{
        typesToFetch.push(reqType);
    }
    
    // figure out which individual definitions to skip
    const defSkipLookup = {};
    if(is.array(opts.excludeDefinitions)){
        for(const dp of opts.excludeDefinitions) defSkipLookup[dp] = true;
    }
    
    // process all the requested types
    const ans = [];
    const doCheckTags = is.array(opts.excludeTags);
    for(const t of typesToFetch){
        processTypeDummyData:
        for(const tp of Object.keys(muQUnitUtil.allDummyData[t])){
            if(doCheckTags){
                for(const et of opts.excludeTags){
                    if(muQUnitUtil.allDummyData[t][tp].hasTag(et)) continue processTypeDummyData;
                }
            }
            if(!defSkipLookup[`${t}.${tp}`]) ans.push(muQUnitUtil.allDummyData[t][tp]);
        }
    }
    return ans;
}
muQUnitUtil.dummyData = dummyData;

/**
 * A function to return all dummy data except those for the given
 * types and those matching the given tags tags.
 *
 * This is a shortcut for:
 * 
 * ```
 * .dummyData(
 *     &apos;*&apos;,
 *     {
 *         excludeTypes: arguments[0],
 *         excludeTags: arguments[1],
 *         excludeDefinitions: arguments[2]
 *     }
 * )
 * ```
 *
 * @param {string[]} [excludeTypes]
 * @param {string[]} [excludeTags]
 * @param {string[]} [excludeDefinitions]
 * @return {DummyData[]}
 */
function dummyDataExcept(excludeTypes, excludeTags, excludeDefinitions){
    if(is.not.array(excludeTypes)) excludeTypes = [];
    if(is.not.array(excludeTags)) excludeTags = [];
    if(is.not.array(excludeDefinitions)) excludeDefinitions = [];
    return dummyData(&apos;*&apos;, {excludeTypes, excludeTags, excludeDefinitions});
}
muQUnitUtil.dummyDataExcept = dummyDataExcept;

/**
 * A function to return all basic dummy data, i.e. all dummy data tagged
 * `basic`.
 *
 * This is a shortcut for `dummyDataWithAnyTag(&apos;basic&apos;)`.
 *
 * @return {DummyData[]}
 */
function dummyBasicData(){
    return dummyDataWithAnyTag(&apos;basic&apos;);
}
muQUnitUtil.dummyBasicData = dummyBasicData;

/**
 * A function to return all basic dummy data that&apos;s not an object, i.e. all
 * dummy data tagged `basic` that does not have either the type or tag
 * `object`.
 *
 * @return {DummyData[]}
 */
function dummyBasicPrimitives(){
    const ans = [];
    for(const dd of dummyBasicData()){
        if(dd.type != &apos;object&apos; &amp;&amp; !dd.hasTag(&apos;object&apos;)) ans.push(dd);
    }
    return ans;
}
muQUnitUtil.dummyBasicPrimitives = dummyBasicPrimitives;

/**
 * A function to return all basic dummy data except those for zero or more
 * given types.
 *
 * @param {...string} excludeTypes
 * @return {DummyData[]}
 */
function dummyBasicDataExcept(...excludeTypes){
    const excludeLookup = {};
    for(const et of excludeTypes) excludeLookup[et] = true;
    const ans = [];
    for(const dd of dummyBasicData()){
        if(!excludeLookup[dd.type]){
            ans.push(dd);
        }
    }
    return ans;
}
muQUnitUtil.dummyBasicDataExcept = dummyBasicDataExcept;

/**
 * A function to return all basic dummy primitives except those for zero or
 * more given types.
 *
 * @param {...string} excludeTypes
 * @return {DummyData[]}
 */
function dummyBasicPrimitivesExcept(...excludeTypes){
    const excludeLookup = {};
    for(const et of excludeTypes) excludeLookup[et] = true;
    const ans = [];
    for(const dd of dummyBasicPrimitives()){
        if(!excludeLookup[dd.type]){
            ans.push(dd);
        }
    }
    return ans;
}
muQUnitUtil.dummyBasicPrimitivesExcept = dummyBasicPrimitivesExcept;

/**
 * Returns the dummy data of one or more types.
 * 
 * @param {...string} typeList
 * @return {DummyData[]}
 * @throws {TypeError}
 */
function dummyDataByType(...typeList){
    if(!is.all.string(typeList)) throw new TypeError(&apos;all specified types must be strings&apos;);
    const ans = [];
    for(const t of typeList){
        if(is.object(muQUnitUtil.allDummyData[t])) ans.push(...Object.values(muQUnitUtil.allDummyData[t]));
    }
    return ans;
}
muQUnitUtil.dummyDataByType = dummyDataByType;

/**
 * Returns the dummy data matching **any** of the given tags.
 *
 * @param {...string} tagList
 * @return {DummyData[]}
 * @throws {TypeError}
 */
function dummyDataWithAnyTag(...tagList){
    if(!is.all.string(tagList)) throw new TypeError(&apos;all specified tags must be strings&apos;);
    const ans = [];
    for(const td of Object.values(muQUnitUtil.allDummyData)){
        for(const dd of Object.values(td)){
            // test if any requested tag is present
            let anyPresent = false;
            for(const t of tagList){
                if(dd.hasTag(t)){
                    anyPresent = true;
                    break;
                }
            }
            if(anyPresent) ans.push(dd);
        }
        
    }
    return ans;
}
muQUnitUtil.dummyDataWithAnyTag = dummyDataWithAnyTag;

/**
 * Returns the dummy data matching **all** of the given tags.
 * 
 * @param {...string} tagList
 * @return {DummyData[]}
 * @throws {TypeError}
 */
function dummyDataWithAllTags(...tagList){
    if(!is.all.string(tagList)) throw new TypeError(&apos;all specified tags must be strings&apos;);
    const ans = [];
    for(const td of Object.values(muQUnitUtil.allDummyData)){
        for(const dd of Object.values(td)){
            // make sure every tag is present
            let allPresent = true;
            for(const t of tagList){
                if(!dd.hasTag(t)){
                    allPresent = false;
                    break;
                }
            }
            if(allPresent) ans.push(dd);
        }
    }
    return ans;
}
muQUnitUtil.dummyDataWithAllTags = dummyDataWithAllTags;

// initialise the dummy data
refreshDummyData();</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
